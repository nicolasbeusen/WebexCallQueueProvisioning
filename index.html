<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Webex Calling – User Queue Assignment</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    pre.json { white-space: pre-wrap; word-break: break-word; }
  </style>
</head>
<body class="min-h-screen bg-slate-50 text-slate-800">
  <div class="max-w-6xl mx-auto p-4 md:p-8">
    <header class="flex items-center justify-between gap-4">
      <h1 class="text-2xl md:text-3xl font-semibold">Webex Calling – Assign User to Queues</h1>
      <span class="text-xs text-slate-500">Tailwind + Vanilla JS</span>
    </header>

    <!-- Auth & Context -->
    <section class="mt-6 grid grid-cols-1 lg:grid-cols-3 gap-4">
      <div class="bg-white rounded-2xl shadow p-4 space-y-3 lg:col-span-1">
        <h2 class="text-lg font-semibold">1) Authentication</h2>
        <label class="block text-sm">Webex Access Token (Bearer)
          <input id="token" type="password" placeholder="Paste admin token (telephony_config scopes)" class="mt-1 w-full rounded-lg border p-2 outline-none focus:ring focus:ring-sky-200" />
        </label>
        <button id="btnInit" class="px-3 py-2 rounded-xl bg-sky-600 text-white hover:bg-sky-700">Initialize</button>
        <div id="meInfo" class="text-sm text-slate-600"></div>
        <p class="text-xs text-slate-500">Token is stored only in-memory and requests go directly to the Webex API.</p>
      </div>

      <div class="bg-white rounded-2xl shadow p-4 space-y-2 lg:col-span-2">
        <h2 class="text-lg font-semibold">2) Target user (hardcoded email)</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm">
          <div>
            <div class="text-slate-500">User Email</div>
            <code id="emailLabel" class="block mt-1 text-xs bg-slate-100 p-2 rounded">—</code>
          </div>
          <div>
            <div class="text-slate-500">Person ID</div>
            <code id="personIdLabel" class="block mt-1 text-xs bg-slate-100 p-2 rounded">—</code>
          </div>
          <div>
            <div class="text-slate-500">Agent ID</div>
            <code id="agentIdLabel" class="block mt-1 text-xs bg-slate-100 p-2 rounded">—</code>
          </div>
          <div>
            <div class="text-slate-500">User Location ID</div>
            <code id="locationIdLabel" class="block mt-1 text-xs bg-slate-100 p-2 rounded">—</code>
          </div>
        </div>
        <p class="text-xs text-slate-500 mt-2">Email is hardcoded in the script; location is derived from the user details.</p>
      </div>
    </section>

    <!-- Queues UI -->
    <section class="mt-6 grid grid-cols-1 lg:grid-cols-3 gap-4">
      <div class="bg-white rounded-2xl shadow p-4 space-y-3 lg:col-span-2">
        <h2 class="text-lg font-semibold">3) Queues in User's Location</h2>
        <div id="queuesContainer" class="grid grid-cols-1 md:grid-cols-2 gap-2"></div>
        <div class="flex gap-2 mt-3">
          <button id="btnSave" class="px-3 py-2 rounded-xl bg-emerald-600 text-white hover:bg-emerald-700 disabled:opacity-40" disabled>Save Changes</button>
          <button id="btnReload" class="px-3 py-2 rounded-xl bg-slate-700 text-white hover:bg-slate-800 disabled:opacity-40" disabled>Reload</button>
        </div>
      </div>

      <div class="bg-white rounded-2xl shadow p-4 space-y-3 lg:col-span-1">
        <h2 class="text-lg font-semibold">4) API Console</h2>
        <div class="text-xs text-slate-500"><span>Last request:</span> <span id="lastReq" class="font-mono"></span></div>
        <pre id="log" class="json text-xs bg-slate-900 text-slate-100 p-3 rounded-xl overflow-auto max-h-96"></pre>
      </div>
    </section>

    <footer class="mt-8 text-xs text-slate-500">
      <p>Flow:</p>
      <ol class="list-decimal ml-6">
        <li>Resolve <code>personId</code> via <code>/v1/people?email</code></li>
        <li>Get user calling details via <code>/v1/people/{personId}?callingData=true</code> → derive <code>locationId</code></li>
        <li>List queues in that location via <code>/v1/telephony/config/queues?locationId</code></li>
        <li>Read queue-agent assignments via <code>/v1/telephony/config/queues/agents?locationId</code>, filter by <code>personId</code> → derive <code>agentId</code> & selected queues</li>
        <li>On save: add/remove using <code>POST</code>/<code>DELETE</code> to <code>/v1/telephony/config/queues/agents</code></li>
      </ol>
      <p class="mt-2">Some admin endpoints may be subject to CORS from the browser; if so, proxy these requests server-side. Token must include <code>spark-admin:telephony_config_read</code> and <code>spark-admin:telephony_config_write</code>.</p>
    </footer>
  </div>

  <script>
    // ======== HARD-CODED TARGET ========
    // TODO: set this constant to your target user now; later make it dynamic.
    const USER_EMAIL = "agent@example.com"; // the end user's email whose queues you want to manage

    // ======== API Helpers ========
    const API_BASE = 'https://webexapis.com/v1';
    const $ = (id) => document.getElementById(id);
    const setLastReq = (t) => $('lastReq').textContent = t;
    const show = (obj) => $('log').textContent = (typeof obj === 'string') ? obj : JSON.stringify(obj, null, 2);

    function authHeaders() {
      const token = $('token').value.trim();
      if (!token) throw new Error('Missing access token');
      return { 'Authorization': `Bearer ${token}` };
    }

    function urlFor(path, params = {}) {
      const u = new URL(API_BASE + path);
      Object.entries(params).forEach(([k,v]) => (v ?? '') !== '' && u.searchParams.append(k, v));
      return u;
    }

    async function apiGet(path, params = {}) {
      const u = urlFor(path, params);
      setLastReq('GET ' + u.pathname + u.search);
      const res = await fetch(u, { headers: { ...authHeaders() } });
      if (!res.ok) throw new Error(`GET ${u.pathname + u.search} → ${res.status} ${res.statusText}`);
      return res.json();
    }

    async function apiWrite(path, method = 'POST', body = null) {
      const u = urlFor(path);
      setLastReq(method + ' ' + u.pathname + u.search);
      const res = await fetch(u, {
        method,
        headers: { ...authHeaders(), 'Content-Type': 'application/json' },
        body: body ? JSON.stringify(body) : null
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(`${method} ${u.pathname + u.search} → ${res.status} ${res.statusText}
${text}`);
      }
      return res.json().catch(() => ({}));
    }

    // ======== App State ========
    const state = {
      person: null,
      personId: null,
      locationId: null,
      agentId: null,
      queues: [],           // [{id, name, ...}]
      assignedQueueIds: new Set(),
    };

    function enableActions(on) {
      $('btnSave').disabled = !on;
      $('btnReload').disabled = !on;
    }

    function renderContext() {
      $('emailLabel').textContent = USER_EMAIL || '—';
      $('personIdLabel').textContent = state.personId || '—';
      $('agentIdLabel').textContent = state.agentId || '—';
      $('locationIdLabel').textContent = state.locationId || '—';
    }

    function renderQueues() {
      const wrap = $('queuesContainer');
      wrap.innerHTML = '';
      state.queues.forEach(q => {
        const id = `q_${q.id}`;
        const li = document.createElement('label');
        li.className = 'flex items-center gap-3 p-2 rounded-lg border hover:bg-slate-50';
        li.innerHTML = `
          <input type=\"checkbox\" class=\"queueBox h-4 w-4\" data-queueid=\"${q.id}\" id=\"${id}\" ${state.assignedQueueIds.has(q.id) ? 'checked' : ''} />
          <div>
            <div class=\"font-medium\">${q.name || q.displayName || q.id}</div>
            <div class=\"text-xs text-slate-500\">${q.id}</div>
          </div>`;
        wrap.appendChild(li);
      });
      enableActions(true);
    }

    // ======== Data Fetch Steps ========
    async function initFlow() {
      try {
        enableActions(false);
        $('meInfo').textContent = '';
        show('');

        // 0) sanity check token
        const me = await apiGet('/people/me');
        $('meInfo').textContent = `Authed as ${me.displayName || me.emails?.[0] || me.id}`;

        // 1) resolve person by hardcoded email
        const ppl = await apiGet('/people', { email: USER_EMAIL, max: 1 });
        const person = (ppl.items || [])[0];
        if (!person) throw new Error('No user found for USER_EMAIL');
        state.person = person;
        state.personId = person.id;

        // 2) get person calling details to derive locationId
        const full = await apiGet(`/people/${encodeURIComponent(state.personId)}`, { callingData: true });
        const cd = full.callingData || full; // sometimes nested
        const locId = cd.locationId || cd.primaryLocationId || cd.siteId || full.locationId || null;
        if (!locId) throw new Error('Could not derive locationId from person callingData');
        state.locationId = locId;

        // 3) list queues for that location (authoritative list of queues)
        const qres = await apiGet('/telephony/config/queues', { locationId: state.locationId, max: 2000 });
        state.queues = qres.items || qres.data || [];

        // 4) obtain the AGENT ID for this user (filter by personId). This call is NOT used to derive queue list.
        const ares = await apiGet('/telephony/config/queues/agents', { locationId: state.locationId, max: 2000 });
        const agents = ares.items || ares.data || [];
        const mine = agents.filter(a => a.personId === state.personId || a.person?.id === state.personId);
        state.agentId = mine[0]?.agentId || mine[0]?.id || null;

        // 5) determine which of the location's queues the user is currently assigned to
        // by checking each queue's details endpoint for membership
        state.assignedQueueIds = new Set();

        async function mapLimit(items, limit, fn) {
          let i = 0;
          const results = new Array(items.length);
          const workers = new Array(Math.min(limit, items.length)).fill(0).map(async () => {
            while (i < items.length) {
              const idx = i++;
              results[idx] = await fn(items[idx], idx);
            }
          });
          await Promise.all(workers);
          return results;
        }

        await mapLimit(state.queues, 5, async (q) => {
          const path = `/telephony/config/locations/${encodeURIComponent(state.locationId)}/queues/${encodeURIComponent(q.id)}`;
          const details = await apiGet(path);
          const members = details.agents || details.queueAgents || details.members || [];
          const isMember = members.some(m => (state.agentId && (m.agentId === state.agentId || m.id === state.agentId)) || (m.personId === state.personId) || (m.person?.id === state.personId));
          if (isMember) state.assignedQueueIds.add(q.id);
          return null;
        });

        renderContext();
        renderQueues();
        show({ me, person, calling: full, queues: state.queues, agentRecord: mine[0] || null, assignedQueueIds: Array.from(state.assignedQueueIds) });
      } catch (e) {
        renderContext();
        show(e.message || String(e));
      }
    }

    // ======== Write (Assign/Remove) ========
    async function saveChanges() {
      try {
        enableActions(false);
        const boxes = Array.from(document.querySelectorAll('.queueBox'));
        const desired = new Set(boxes.filter(b => b.checked).map(b => b.dataset.queueid));
        const current = new Set(Array.from(state.assignedQueueIds));

        const toAdd = Array.from(desired).filter(id => !current.has(id));
        const toRemove = Array.from(current).filter(id => !desired.has(id));

        const ops = [];
        for (const queueId of toAdd) {
          const body = { queueId, personId: state.personId };
          if (state.agentId) body.agentId = state.agentId;
          ops.push(apiWrite('/telephony/config/queues/agents', 'POST', body));
        }
        for (const queueId of toRemove) {
          const body = { queueId, personId: state.personId };
          if (state.agentId) body.agentId = state.agentId;
          ops.push(apiWrite('/telephony/config/queues/agents', 'DELETE', body));
        }

        if (ops.length === 0) {
          show('No changes to save.');
          enableActions(true);
          return;
        }

        const results = await Promise.allSettled(ops);
        show({ toAdd, toRemove, results });

        // Refresh assignments
        const ares = await apiGet('/telephony/config/queues/agents', { locationId: state.locationId, max: 2000 });
        const agents = ares.items || ares.data || [];
        const mine = agents.filter(a => a.personId === state.personId || a.person?.id === state.personId);
        state.assignedQueueIds = new Set(mine.map(a => a.queueId || a.queue?.id).filter(Boolean));
        renderQueues();
        enableActions(true);
      } catch (e) {
        show(e.message || String(e));
        enableActions(true);
      }
    }

    // ======== Wire up ========
    $('btnInit').addEventListener('click', initFlow);
    $('btnReload').addEventListener('click', initFlow);
    $('btnSave').addEventListener('click', saveChanges);

    // Set labels
    renderContext();
  </script>
</body>
</html>
